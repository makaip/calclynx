=== f:\Programming\GitHub\mathboard\index.html ===
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>MathBoard</title>
  
  <!-- MathQuill CSS -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/mathquill/0.10.1/mathquill.css" />
  <!-- Custom Styles -->
  <link rel="stylesheet" href="styles.css" />
</head>
<body>
  <!-- Hamburger Menu -->
  <div id="menu-container">
    <button id="hamburgerBtn">â˜°</button>
    <div id="menu">
      <ul>
        <li class="menu-item">File
          <ul class="submenu">
            <li id="exportOption">Export JSON</li>
            <li id="importOption">Import JSON</li>
          </ul>
        </li>
        <li class="menu-item">Edit
          <ul class="submenu">
            <li>Undo</li>
            <li>Redo</li>
          </ul>
        </li>
        <li class="menu-item">View
          <ul class="submenu">
            <li>Zoom In</li>
            <li>Zoom Out</li>
          </ul>
        </li>
        <li class="menu-item">Insert
          <ul class="submenu">
            <li>New Math Group</li>
          </ul>
        </li>
        <li class="menu-item">Tools
          <ul class="submenu">
            <li>Settings</li>
          </ul>
        </li>
      </ul>
    </div>
  </div>
  
  <!-- The huge canvas holds all math groups -->
  <div id="canvas"></div>

  <!-- Hidden file input for importing JSON -->
  <input type="file" id="importInput" accept=".json" style="display: none;">
  
  <!-- External Libraries -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/mathquill/0.10.1/mathquill.min.js"></script>
  
  <!-- Main Scripts -->
  <script src="scripts/filemanager.js"></script>
  <script src="scripts/navigation.js"></script>
  <script src="scripts/mathboard.js"></script>
  <script src="scripts/mathgroup.js"></script>
  <script src="scripts/mathfield.js"></script>
  <script src="script.js"></script>
</body>
</html>


=== f:\Programming\GitHub\mathboard\out.txt ===


=== f:\Programming\GitHub\mathboard\script.js ===
// script.js
document.addEventListener('DOMContentLoaded', () => {
  // Create and store MathBoard instance globally.
  window.mathBoard = new MathBoard();

  // ----- New Hamburger Menu Logic -----
  const hamburgerBtn = document.getElementById('hamburgerBtn');
  const menu = document.getElementById('menu');

  // Toggle menu display when clicking the hamburger button.
  hamburgerBtn.addEventListener('click', (e) => {
    e.stopPropagation();
    menu.style.display = menu.style.display === 'block' ? 'none' : 'block';
  });

  // Hide the menu when clicking outside the menu container.
  document.addEventListener('click', (e) => {
    if (!document.getElementById('menu-container').contains(e.target)) {
      menu.style.display = 'none';
    }
  });

  // Export JSON functionality.
  document.getElementById('exportOption').addEventListener('click', () => {
    window.mathBoard.fileManager.exportData();
    menu.style.display = 'none';
  });

  // Import JSON functionality.
  document.getElementById('importOption').addEventListener('click', () => {
    document.getElementById('importInput').click();
    menu.style.display = 'none';
  });

  // When a file is chosen, read its contents and import the data.
  document.getElementById('importInput').addEventListener('change', (event) => {
    const file = event.target.files[0];
    if (file) {
      const reader = new FileReader();
      reader.onload = function(e) {
        try {
          const jsonData = e.target.result;
          window.mathBoard.fileManager.importData(jsonData);
        } catch (err) {
          console.error("Error reading JSON file:", err);
        }
      };
      reader.readAsText(file);
    }
    // Reset the file input for future uploads.
    event.target.value = '';
  });

});


=== f:\Programming\GitHub\mathboard\styles.css ===
@import url('https://fonts.googleapis.com/css2?family=Inter:ital,opsz,wght@0,14..32,100..900;1,14..32,100..900&family=Jost:ital,wght@0,100..900;1,100..900&display=swap');

/* Reset and basic styling */
html, body {
    margin: 0;
    padding: 0;
    overflow: hidden;
    width: 100%;
    height: 100%;
    background-color: #1d1d1d;
    font-family: 'Inter', sans-serif;
  }
  
  /* Huge canvas with dotted background extending 20,000x20,000px */
  #canvas {
    position: absolute;
    top: -10000px;
    left: -10000px;
    width: 20000px;
    height: 20000px;
    background-color: #1d1d1d;
    background-image: radial-gradient(#282828 1px, transparent 1px);
    background-size: 20px 20px;
    transform-origin: 0 0;
  }
  
/* Math group styling with 10px padding for hover/drag detection */
.math-group {
    position: absolute;
    display: flex;
    flex-direction: column;
    gap: 10px;
    padding: 10px;
    cursor: grab; /* Indicates draggable area */
  }
  
  /* Hover state: white outline at 50% opacity */
  .math-group:hover {
    outline: 2px solid rgba(255, 255, 255, 0.05);
    border-radius: 5px;
  }
  
  /* Selected state: green outline */
  .math-group.selected {
    outline: 2px solid #00c59a;
    border-radius: 5px;
  }
  
  /* Dragging state: green outline with grabbing cursor */
  .math-group.dragging {
    outline: 2px solid #00c59a !important;
    cursor: grabbing;
  }

  .selection-box {
    position: absolute;
    border: 1px dashed #00c59a;
    background-color: rgba(0, 197, 154, 0.15);
    pointer-events: none;
    z-index: 1000;
  }
  
  
  /* Math field container styling */
  .math-field-container {
    display: flex;
    flex-direction: column;
    position: relative;
    padding: 5px;
  }
  
  /* Editable math field styling */
  .math-field {
    border: 1px solid #444;
    min-height: 40px;
    display: inline-block;
    padding: 5px;
    font-size: 18px;
    white-space: nowrap;
    overflow: hidden;
    background: #1e1e1e;
    color: #ffffff;
    border-radius: 5px;
  }
  
  /* MathQuill styling overrides */
  .mq-editable-field,
  .mq-math-mode {
    background: #1e1e1e !important;
    color: #ffffff !important;
    border-color: #666 !important;
  }
  
  .mq-focused {
    border-color: #00c59a !important;
  }


  
  .mq-editable-field .mq-cursor {
    border-left: 2px solid #ffffff !important;
  }
  

  button {
    background-color: #1e1e1e; /* Green */
    border: #666 1px solid;
    color: white;
    padding: 5px 10px;
    text-align: center;
    text-decoration: none;
    display: inline-block;
    font-size: 14px;
    cursor: pointer;
    border-radius: 5px;
    transition: background-color 0.3s ease, transform 0.2s ease;
  }
  
  button:hover {
    border: #00c59a 1px solid;
  }
  
  button:active {
    background: #00c59a;
  }
  
  button:disabled {
    background-color: #cccccc;
    cursor: not-allowed;
  }
  
  /* Hamburger Menu Styles */
#menu-container {
  position: fixed;
  top: 10px;
  left: 10px;
  z-index: 1001;
}

#hamburgerBtn {
  background: transparent;
  border: none;
  font-size: 24px;
  color: white;
  cursor: pointer;
}

#menu {
  display: none;
  background-color: #1d1d1d;
  border: 1px solid #666;
  border-radius: 5px;
  margin-top: 5px;
  padding: 5px;
}

#menu ul {
  list-style: none;
  margin: 0;
  padding: 0;
}

#menu li {
  padding: 5px 10px;
  color: white;
  cursor: pointer;
  position: relative;
}

#menu li:hover {
  background-color: #333;
}

.submenu {
  display: none;
  position: absolute;
  top: 0;
  left: 100%;
  background-color: #1d1d1d;
  border: 1px solid #666;
  border-radius: 5px;
  padding: 5px;
  min-width: 150px;
  z-index: 1001;
}

.menu-item:hover > .submenu {
  display: block;
}


=== f:\Programming\GitHub\mathboard\scripts\filemanager.js ===
// scripts/filemanager.js
class FileManager {
    constructor(board) {
      this.board = board;
    }
  
    saveState() {
      const groups = [];
      const mathGroupElements = this.board.canvas.querySelectorAll('.math-group');
      mathGroupElements.forEach((group) => {
        const left = group.style.left;
        const top = group.style.top;
        const fields = [];
        group.querySelectorAll('.math-field-container').forEach((container) => {
          if (container.dataset.latex) {
            fields.push(container.dataset.latex);
          }
        });
        groups.push({ left, top, fields });
      });
      const stateString = JSON.stringify(groups);
      localStorage.setItem("mathBoardState", stateString);
    }
  
    loadState() {
      const stateString = localStorage.getItem("mathBoardState");
      if (!stateString) return;
      let groups;
      try {
        groups = JSON.parse(stateString);
      } catch (e) {
        console.error("Failed to parse state from localStorage:", e);
        return;
      }
      groups.forEach((groupData) => {
        new MathGroup(this.board, groupData.left, groupData.top, groupData);
      });
    }
  
    exportData() {
      const groups = [];
      const mathGroupElements = this.board.canvas.querySelectorAll('.math-group');
      mathGroupElements.forEach((group) => {
        const left = group.style.left;
        const top = group.style.top;
        const fields = [];
        group.querySelectorAll('.math-field-container').forEach((container) => {
          if (container.dataset.latex) {
            fields.push(container.dataset.latex);
          }
        });
        groups.push({ left, top, fields });
      });
      const dataStr = JSON.stringify(groups, null, 2);
      const blob = new Blob([dataStr], { type: "application/json" });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = "mathboard-data.json";
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
    }
  
    importData(jsonData) {
      try {
        const groups = JSON.parse(jsonData);
        // Clear the current canvas (remove all existing math groups).
        this.board.canvas.innerHTML = '';
        groups.forEach((groupData) => {
           new MathGroup(this.board, groupData.left, groupData.top, groupData);
        });
        // Save the new state.
        this.saveState();
      } catch (error) {
        console.error("Failed to import data:", error);
      }
    }
  }
  

=== f:\Programming\GitHub\mathboard\scripts\mathboard.js ===
const MQ = MathQuill.getInterface(2);

class MathBoard {
  constructor() {
    // Canvas and panning properties.
    this.canvas = document.getElementById('canvas');
    this.isPanning = false;
    this.panStart = { x: 0, y: 0 };
    this.canvasOffset = { x: 0, y: 0 };
    this.spaceDown = false;
    this.scale = 1;
    this.canvasInitialOffset = { x: -10000, y: -10000 };

    // Initialize FileManager and load saved state (if any)
    this.fileManager = new FileManager(this);
    this.fileManager.loadState();

    // Variables for group dragging.
    this.groupDragging = false;
    this.draggedGroup = null;
    this.dragOffsetX = 0;
    this.dragOffsetY = 0;
    this.margin = 10;

    // Box select properties.
    this.isBoxSelecting = false;
    this.boxSelectStart = { x: 0, y: 0 };
    this.selectionBox = null;

    this.initEventListeners();

    this.navigation = new Navigation(this);
    this.navigation.init();
  }

  // -------------------------
  // EVENT INITIALIZERS (unchanged except where noted)
  // -------------------------
  initEventListeners() {
    this.initGlobalKeyHandlers();
    this.initDocumentClickHandler();
    this.initGroupDragging();
    this.initWindowResizeHandler();
    this.initDoubleClickHandler();
  }

  initGlobalKeyHandlers() {
    document.addEventListener('keydown', (e) => {
      if (e.code === 'Space') {
        this.spaceDown = true;
      }
      if (
        (e.key === 'Backspace' || e.key === 'Delete' || e.key === 'x') &&
        !e.ctrlKey &&
        !e.altKey &&
        !e.metaKey
      ) {
        const selectedGroups = document.querySelectorAll('.math-group.selected');
        if (selectedGroups.length > 0) {
          e.preventDefault();
          selectedGroups.forEach((group) => {
            group.remove();
          });
          // Save updated state
          this.fileManager.saveState();
        }
      }
    });

    document.addEventListener('keyup', (e) => {
      if (e.code === 'Space') {
        this.spaceDown = false;
      }
    });
  }

  
  initDocumentClickHandler() {
    document.addEventListener('click', (event) => {
      if (this.isPanning || this.groupDragging) return;
      const mathContainer = event.target.closest('.math-field-container');
      if (mathContainer && !mathContainer.querySelector('.mq-editable-field')) {
        event.stopPropagation();
        MathField.edit(mathContainer);
        return;
      }
      if (event.target.closest('.math-field-container')) return;
      const mathGroupTarget = event.target.closest('.math-group');
      if (mathGroupTarget) {
        if (!event.shiftKey) {
          document.querySelectorAll('.math-group').forEach((group) => group.classList.remove('selected'));
          mathGroupTarget.classList.add('selected');
        } else {
          mathGroupTarget.classList.toggle('selected');
        }
      } else {
        document.querySelectorAll('.math-group').forEach((group) => group.classList.remove('selected'));
      }
    });
  }

  initGroupDragging() {
    document.addEventListener('mousedown', (event) => {
      if (event.button !== 0 || this.spaceDown) return;
      if (event.target.closest('.mq-editable-field')) return;
      let target = event.target;
      while (target && !target.classList.contains('math-group')) {
        target = target.parentElement;
      }
      if (target && target.classList.contains('math-group')) {
        let groups;
        if (target.classList.contains('selected')) {
          groups = Array.from(document.querySelectorAll('.math-group.selected'));
        } else {
          groups = [target];
        }
        this.groupDragging = true;
        this.selectedGroups = groups;
        this.dragStart = { x: event.clientX, y: event.clientY };
        this.initialPositions = groups.map((group) => ({
          group: group,
          left: parseInt(group.style.left, 10),
          top: parseInt(group.style.top, 10)
        }));
        groups.forEach((group) => group.classList.add('dragging'));
        event.stopPropagation();
      }
    });

    document.addEventListener('mousemove', (event) => {
      if (this.groupDragging && this.selectedGroups) {
        const deltaX = event.clientX - this.dragStart.x;
        const deltaY = event.clientY - this.dragStart.y;
        this.initialPositions.forEach((item) => {
          item.group.style.left = (item.left + deltaX) + 'px';
          item.group.style.top = (item.top + deltaY) + 'px';
        });
      }
    });

    document.addEventListener('mouseup', () => {
      if (this.groupDragging && this.selectedGroups) {
        this.selectedGroups.forEach((group) => group.classList.remove('dragging'));
        this.groupDragging = false;
        this.selectedGroups = null;
        this.initialPositions = null;
        // Save state after dragging ends.
        this.fileManager.saveState();
      }
    });
  }

  initWindowResizeHandler() {
    window.addEventListener('resize', () => {
      this.updateTransform();
    });
  }

  initDoubleClickHandler() {
    document.addEventListener('dblclick', (event) => {
      if (this.isPanning) return;
      const coords = this.screenToCanvas(event.clientX, event.clientY);
      // Create a new MathGroup and then save state.
      new MathGroup(this, coords.x, coords.y);
      this.fileManager.saveState()
    });
  }

  updateTransform() {
    this.canvas.style.transform = `translate(${this.canvasOffset.x}px, ${this.canvasOffset.y}px)`;
  }

  selectStacksWithinBox(selectionRect) {
    document.querySelectorAll('.math-group').forEach((group) => {
      group.classList.remove('selected');
    });

    document.querySelectorAll('.math-group').forEach((group) => {
      const groupRect = group.getBoundingClientRect();
      if (
        groupRect.left >= selectionRect.left &&
        groupRect.right <= selectionRect.right &&
        groupRect.top >= selectionRect.top &&
        groupRect.bottom <= selectionRect.bottom
      ) {
        group.classList.add('selected');
      }
    });
  }

  screenToCanvas(x, y) {
    return {
      x: (x - (this.canvasInitialOffset.x + this.canvasOffset.x)) / this.scale,
      y: (y - (this.canvasInitialOffset.y + this.canvasOffset.y)) / this.scale,
    };
  }
}


=== f:\Programming\GitHub\mathboard\scripts\mathfield.js ===
class MathField {
  constructor(mathGroup) {
    this.mathGroup = mathGroup;
    this.createContainer();
    this.createMathField();
    this.attachEventListeners();
    this.mathField.focus();
  }

  createContainer() {
    this.container = document.createElement('div');
    this.container.className = 'math-field-container';
    this.container.dataset.latex = '';
    this.container.addEventListener('mousedown', (e) => e.stopPropagation());
    this.mathGroup.element.appendChild(this.container);
  }

  createMathField() {
    this.mathFieldElement = document.createElement('div');
    this.mathFieldElement.className = 'math-field';
    this.container.appendChild(this.mathFieldElement);
    this.mathField = MQ.MathField(this.mathFieldElement, {
      spaceBehavesLikeTab: true,
    });
  }

  attachEventListeners() {
    this.mathFieldElement.addEventListener('keydown', (event) => {
      if (
        event.key === 'Backspace' &&
        !event.ctrlKey &&
        !this.mathField.latex().trim()
      ) {
        const groupElement = this.mathGroup.element;
        if (
          groupElement.children.length > 1 &&
          this.container !== groupElement.firstElementChild
        ) {
          event.preventDefault();
          const previousContainer = this.container.previousElementSibling;
          this.container.remove();
          MathField.edit(previousContainer);
          this.fileManager.saveState();
          return;
        }
      }
  
      if (event.key === 'Backspace' && event.ctrlKey) {
        event.preventDefault();
        if (event.shiftKey) {
          this.mathGroup.remove();
        } else {
          this.container.remove();
          if (!this.mathGroup.element.querySelector('.math-field-container')) {
            this.mathGroup.remove();
          }
        }
        this.fileManager.saveState();
        return;
      }

      if (event.key === 'Enter') {
        event.preventDefault();
        
        if (event.ctrlKey) {
          this.mathFieldElement.blur();
        } else {
          if (this.container === this.mathGroup.element.lastElementChild) {
            this.mathGroup.addMathField();
          } else {
            this.mathGroup.insertMathFieldAfter(this.container);
          }
        }

        this.finalize();
      }
      
    });
  }
      
  finalize() {
    const latex = this.mathField.latex().trim();
    if (!latex) {
      this.container.remove();
      if (!this.mathGroup.element.querySelector('.math-field-container')) {
        this.mathGroup.remove();
      }
      this.mathGroup.board.saveState();
      return;
    }
    this.container.dataset.latex = latex;
    this.container.innerHTML = '';
    const staticMath = document.createElement('div');
    staticMath.className = 'math-field';
    this.container.appendChild(staticMath);
    MQ.StaticMath(staticMath).latex(latex);
    // Save the state after finalizing the field.
    this.mathGroup.board.saveState();
  }

  // Static method to enable editing on a static math field.
  static edit(container) {
    const existingLatex = container.dataset.latex || '';
    if (container.querySelector('.mq-editable-field')) return;
    container.innerHTML = '';
  
    const mathFieldElement = document.createElement('div');
    mathFieldElement.className = 'math-field';
    container.appendChild(mathFieldElement);
  
    const mathField = MQ.MathField(mathFieldElement, {
      spaceBehavesLikeTab: true,
    });
    mathField.latex(existingLatex);
    mathField.focus();
  
    mathFieldElement.addEventListener('keydown', function (event) {
      if (
        event.key === 'Backspace' &&
        !event.ctrlKey &&
        !mathField.latex().trim()
      ) {
        if (container.previousElementSibling) {
          event.preventDefault();
          const previousContainer = container.previousElementSibling;
          container.remove();
          MathField.edit(previousContainer);
          // Note: Assuming mathGroup instance is accessible, its board.saveState() should be called.
          return;
        }
      }
  
      if (event.key === 'Backspace' && event.ctrlKey) {
        event.preventDefault();
        if (event.shiftKey) {
          container.parentElement.remove();
        } else {
          container.remove();
          const group = container.parentElement;
          if (group && !group.querySelector('.math-field-container')) {
            group.remove();
          }
        }
        return;
      }
      
      if (event.key === 'Enter') {
        event.preventDefault();
        const latex = mathField.latex().trim();
        if (!latex) {
          container.remove();
          const group = container.parentElement;
          if (group && !group.querySelector('.math-field-container')) {
            group.remove();
          }
          return;
        }
        container.dataset.latex = latex;
        container.innerHTML = '';
        const staticMath = document.createElement('div');
        staticMath.className = 'math-field';
        container.appendChild(staticMath);
        MQ.StaticMath(staticMath).latex(latex);
      
        const groupElement = container.parentElement;
        if (groupElement && groupElement.lastElementChild === container && groupElement.mathGroup) {
          groupElement.mathGroup.addMathField();
        } else if (groupElement && groupElement.mathGroup) {
          groupElement.mathGroup.insertMathFieldAfter(container);
        }
      }
      
    });
  
    mathFieldElement.addEventListener('blur', function () {
      setTimeout(() => {
        if (!mathField.latex().trim()) {
          container.remove();
          const group = container.parentElement;
          if (group && !group.querySelector('.math-field-container')) {
            group.remove();
          }
        }
      }, 50);
    });
  }
}


=== f:\Programming\GitHub\mathboard\scripts\mathgroup.js ===
class MathGroup {
  // Now accepts an optional "data" parameter.
  constructor(board, x, y, data = null) {
    this.board = board;
    this.element = document.createElement('div');
    this.element.className = 'math-group';
    // Append "px" when there's no saved state.
    const left = data ? data.left : `${x}px`;
    const top = data ? data.top : `${y}px`;
    this.element.style.left = left;
    this.element.style.top = top;
    this.element.tabIndex = -1; // Make focusable.
    this.element.mathGroup = this;
    board.canvas.appendChild(this.element);
    this.attachFocusOutHandler();

    if (data && data.fields && data.fields.length) {
      // Recreate finalized math fields from saved data.
      data.fields.forEach((latex) => {
        const container = document.createElement('div');
        container.className = 'math-field-container';
        container.dataset.latex = latex;
        this.element.appendChild(container);
        const staticMath = document.createElement('div');
        staticMath.className = 'math-field';
        container.appendChild(staticMath);
        MQ.StaticMath(staticMath).latex(latex);
      });
      // Optionally add a new empty math field.
      this.addMathField();
    } else {
      this.addMathField();
    }
  }

  attachFocusOutHandler() {
    this.element.addEventListener('focusout', () => {
      setTimeout(() => {
        if (!this.element.contains(document.activeElement)) {
          if (this.element.children.length === 1) {
            const container = this.element.children[0];
            if (!container.dataset.latex || container.dataset.latex.trim() === '') {
              this.remove();
            }
          }
        }
      }, 50);
    });
  }

  addMathField() {
    new MathField(this);
  }

  remove() {
    this.element.remove();
    this.fileManager.saveState();
  }

  insertMathFieldAfter(referenceContainer) {
    // Create a new math field.
    const newField = new MathField(this);
    // Insert the new container right after the reference container.
    this.element.insertBefore(newField.container, referenceContainer.nextSibling);
    // Focus on the new math field.
    newField.mathField.focus();
  }
  
  
}



=== f:\Programming\GitHub\mathboard\scripts\navigation.js ===
// navigation.js

class Navigation {
    constructor(board) {
      this.board = board;
      this.boxSelect = {
        isSelecting: false,
        startX: 0,
        startY: 0,
        element: null,
      };
    }
  
    init() {
      this.initCanvasPanning();
      this.initTrackpadNavigation();
      this.initBoxSelection();
      window.addEventListener('resize', () => {
        this.clampPan();
        this.updateTransform();
      });
    }
  
    initCanvasPanning() {
      const canvas = this.board.canvas;
      canvas.addEventListener('mousedown', (e) => {
        // Start panning with middle mouse or left mouse when space is held.
        if (e.button === 1 || (e.button === 0 && this.board.spaceDown)) {
          this.board.isPanning = true;
          this.board.panStart.x = e.clientX - this.board.canvasOffset.x;
          this.board.panStart.y = e.clientY - this.board.canvasOffset.y;
          e.preventDefault();
        }
      });
  
      canvas.addEventListener('mousemove', (e) => {
        if (this.board.isPanning) {
          this.board.canvasOffset.x = e.clientX - this.board.panStart.x;
          this.board.canvasOffset.y = e.clientY - this.board.panStart.y;
          this.clampPan();
          this.updateTransform();
        }
      });
  
      canvas.addEventListener('mouseup', (e) => {
        if (e.button === 1 || e.button === 0) {
          this.board.isPanning = false;
        }
      });
  
      canvas.addEventListener('mouseleave', () => {
        this.board.isPanning = false;
      });
  
      canvas.addEventListener('contextmenu', (e) => e.preventDefault());
    }
  
    clampPan() {
      const minX = window.innerWidth - 10000;
      const maxX = 10000;
      this.board.canvasOffset.x = Math.min(maxX, Math.max(minX, this.board.canvasOffset.x));
  
      const minY = window.innerHeight - 10000;
      const maxY = 10000;
      this.board.canvasOffset.y = Math.min(maxY, Math.max(minY, this.board.canvasOffset.y));
    }
  
    updateTransform() {
      this.board.canvas.style.transform = `translate(${this.board.canvasOffset.x}px, ${this.board.canvasOffset.y}px)`;
    }
  
    initTrackpadNavigation() {
      const canvas = this.board.canvas;
      canvas.addEventListener('wheel', (e) => {
        // Trackpad heuristic: deltaMode 0 with horizontal scrolling or small vertical deltas.
        if (e.deltaMode === 0 && (Math.abs(e.deltaX) > 0 || Math.abs(e.deltaY) < 50)) {
          e.preventDefault();
          this.board.canvasOffset.x -= e.deltaX;
          this.board.canvasOffset.y -= e.deltaY;
          this.clampPan();
          this.updateTransform();
        }
      }, { passive: false });
    }
  
    initBoxSelection() {
      const canvas = this.board.canvas;
      canvas.addEventListener('mousedown', (e) => {
        if (e.button !== 0 || this.board.spaceDown) return;
        if (e.target !== canvas) return;
        this.boxSelect.isSelecting = true;
        this.boxSelect.startX = e.clientX;
        this.boxSelect.startY = e.clientY;
        this.boxSelect.element = document.createElement('div');
        this.boxSelect.element.className = 'box-select-rect';
        this.boxSelect.element.style.position = 'absolute';
        this.boxSelect.element.style.border = '1px dashed #00c59a';
        this.boxSelect.element.style.backgroundColor = 'rgba(0, 197, 154, 0.1)';
        this.boxSelect.element.style.pointerEvents = 'none';
        this.boxSelect.element.style.left = `${this.boxSelect.startX}px`;
        this.boxSelect.element.style.top = `${this.boxSelect.startY}px`;
        this.boxSelect.element.style.width = '0px';
        this.boxSelect.element.style.height = '0px';
        document.body.appendChild(this.boxSelect.element);
      });
  
      document.addEventListener('mousemove', (e) => {
        if (!this.boxSelect.isSelecting) return;
        const startX = this.boxSelect.startX;
        const startY = this.boxSelect.startY;
        const currentX = e.clientX;
        const currentY = e.clientY;
        const left = Math.min(startX, currentX);
        const top = Math.min(startY, currentY);
        const width = Math.abs(currentX - startX);
        const height = Math.abs(currentY - startY);
        this.boxSelect.element.style.left = `${left}px`;
        this.boxSelect.element.style.top = `${top}px`;
        this.boxSelect.element.style.width = `${width}px`;
        this.boxSelect.element.style.height = `${height}px`;
      });
  
      document.addEventListener('mouseup', () => {
        if (!this.boxSelect.isSelecting) return;
        this.boxSelect.isSelecting = false;
        const selectionRect = this.boxSelect.element.getBoundingClientRect();
        this.boxSelect.element.remove();
        this.boxSelect.element = null;
        this.selectGroupsWithinBox(selectionRect);
      });
  
      canvas.addEventListener('mouseleave', () => {
        if (this.boxSelect.isSelecting && this.boxSelect.element) {
          this.boxSelect.element.remove();
          this.boxSelect.isSelecting = false;
        }
      });
    }
  
    selectGroupsWithinBox(selectionRect) {
      document.querySelectorAll('.math-group').forEach((group) => {
        group.classList.remove('selected');
      });
  
      document.querySelectorAll('.math-group').forEach((group) => {
        const groupRect = group.getBoundingClientRect();
        if (
          groupRect.left >= selectionRect.left &&
          groupRect.right <= selectionRect.right &&
          groupRect.top >= selectionRect.top &&
          groupRect.bottom <= selectionRect.bottom
        ) {
          group.classList.add('selected');
        }
      });
    }
  
    // Helper to convert screen coordinates to canvas coordinates.
    screenToCanvas(x, y) {
      return {
        x: (x - (this.board.canvasInitialOffset.x + this.board.canvasOffset.x)) / this.board.scale,
        y: (y - (this.board.canvasInitialOffset.y + this.board.canvasOffset.y)) / this.board.scale,
      };
    }
  }
  

